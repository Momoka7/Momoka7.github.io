---
layout: post
title: "å¯»è·¯ç®—æ³•"
subtitle: "å¸¸ç”¨å¯»è·¯ç®—æ³•çš„å­¦ä¹ ç ”ç©¶"
date: 2024-06-12 10:30:00
author: "Momoka7"
header-style: text
catalog: true
tags:
  - å¯»è·¯ç®—æ³•
  - Python
  - Algorithm
---

# å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼ŒBreadth-First Searchï¼‰

åœ¨æˆ˜æ£‹ç±»æ¸¸æˆä¸­ï¼ˆå¦‚é«˜çº§æˆ˜äº‰ï¼‰ï¼Œåœ°å›¾ä¸€èˆ¬ä¼šè¢«åˆ’åˆ†ä¸ºç½‘æ ¼ï¼Œå¯ç§»åŠ¨å•ä½ä¸€èˆ¬éƒ½æœ‰ä¸€ä¸ªç§»åŠ¨æ­¥æ•°èŒƒå›´ï¼Œåœ¨çŽ©å®¶æ“æŽ§æ—¶ä¼šåœ¨åœ°å›¾ä¸Šæ˜¾ç¤ºå¯ç§»åŠ¨èŒƒå›´ï¼Œå¦‚ä¸‹å›¾ä¸­çš„çº¢è‰²å¦å…‹ã€‚è¦å®žçŽ°è¿™ä¸€åŠŸèƒ½å°±å¯ä½¿ç”¨**BFS**ç®—æ³•äº†ã€‚

![æˆªå›¾](/img/in-post/Pathfinding/8706fa33e26078c9505c9b739a8ad5fc.png)

## åŸºæœ¬æ¦‚å¿µ

ç®—æ³•ä»Žèµ·å§‹èŠ‚ç‚¹å‡ºå‘ï¼Œé¦–å…ˆè®¿é—®ä¸Žèµ·å§‹èŠ‚ç‚¹è·ç¦»ä¸º 1 çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œç„¶åŽè®¿é—®è·ç¦»ä¸º 2 çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¾æ­¤ç±»æŽ¨ã€‚åœ¨ BFS ä¸­ï¼Œæ‰€æœ‰è¾¹çš„æƒé‡ç›¸åŒï¼Œå› æ­¤æ¯æ¬¡ç§»åŠ¨åˆ°ç›¸é‚»èŠ‚ç‚¹çš„ä»£ä»·ç›¸ç­‰ï¼ˆæ— æƒå›¾ï¼‰ã€‚

## ç®—æ³•æ­¥éª¤

BFS ä½¿ç”¨é˜Ÿåˆ—ï¼ˆQueueï¼‰æ•°æ®ç»“æž„æ¥å®žçŽ°ã€‚

1. **åˆå§‹åŒ–**ï¼š
   - å°†èµ·å§‹èŠ‚ç‚¹æ ‡è®°ä¸ºå·²è®¿é—®ï¼Œå¹¶å°†å…¶åŠ å…¥é˜Ÿåˆ—ã€‚
   - åˆ›å»ºä¸€ä¸ªè®°å½•èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®çš„å¸ƒå°”æ•°ç»„æˆ–é›†åˆã€‚
2. **å¼€å§‹éåŽ†**ï¼š
   - ä»Žé˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®¿é—®è¯¥èŠ‚ç‚¹ã€‚
   - å°†è¯¥èŠ‚ç‚¹çš„æ‰€æœ‰æœªè®¿é—®è¿‡çš„é‚»æŽ¥èŠ‚ç‚¹æ ‡è®°ä¸ºå·²è®¿é—®ï¼Œå¹¶ä¾æ¬¡åŠ å…¥é˜Ÿåˆ—ã€‚
3. **ç»§ç»­éåŽ†**ï¼š
   - é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºæˆ–æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹ã€‚

## **ç®—æ³•å®žçŽ°**

ä»¥ä¸‹æ˜¯ BFS ç®—æ³•çš„ä¼ªä»£ç å’Œ Python å®žçŽ°ï¼š

#### ä¼ªä»£ç 

```plaintext
BFS(graph, start):
    create a queue Q
    create a set of visited nodes
    enqueue start to Q
    add start to visited

    while Q is not empty:
        node = dequeue from Q
        for each neighbor in graph.neighbors(node):
            if neighbor is not in visited:
                enqueue neighbor to Q
                add neighbor to visited
```

#### Python å®žçŽ°

```python
from collections import deque

def bfs(graph, start):
    # åˆå§‹åŒ–é˜Ÿåˆ—å’Œå·²è®¿é—®é›†åˆ
    queue = deque([start])
    visited = set([start])

    while queue:
        node = queue.popleft()
        print(node)  # è®¿é—®èŠ‚ç‚¹

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

## **ç¤ºä¾‹**

å‡è®¾æœ‰ä¸€ä¸ªç®€å•çš„æ— æƒå›¾å¦‚ä¸‹ï¼š

```
A - B - C
|   |
D - E
```

è°ƒç”¨`bfs(graph, 'A')`ï¼ŒéåŽ†é¡ºåºä¸ºï¼š`A -> B -> D -> C -> E`ã€‚

## æ€»ç»“

BFS æ˜¯ä¸€ç§ç®€å•çš„å›¾éåŽ†ç®—æ³•ï¼Œç‰¹åˆ«é€‚ç”¨äºŽæ— æƒå›¾çš„æœ€çŸ­è·¯å¾„æŸ¥æ‰¾å’Œå±‚çº§éåŽ†ã€‚ä½†æ˜¯åœ¨å¯»è·¯ç®—æ³•ä¸­ï¼Œå…¶**æ— ç›®çš„æ€§**ä½¿å…¶å¤šäº†å¾ˆå¤šä¸å¿…è¦çš„è®¡ç®—ã€‚

# Best First Search

åŸºäºŽå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œå¼•å…¥äº†å¯å‘å¼æœç´¢ã€‚

åœ¨ Best First Search ä¸­ï¼Œä¸ä¼šå¯¹æ‰€æœ‰çš„ç›¸é‚»è·¯å¾„è¿›è¡Œæœç´¢ï¼Œè€Œæ˜¯åŸºäºŽä¸€ä¸ª**ä¼˜å…ˆåº¦**æ¥æœç´¢ã€‚æ­¤ä¼˜å…ˆåº¦ä¸€èˆ¬ä½¿ç”¨**æ›¼å“ˆé¡¿è·ç¦»**æ¥è®¡ç®—ã€‚

å³ç»™å®šç›®æ ‡ç‚¹ï¼Œå¾…æœç´¢è·¯å¾„ç‚¹ä¼šè®¡ç®—ä¸€ä¸ªå’Œç›®æ ‡ç‚¹çš„æ›¼å“ˆé¡¿è·ç¦»ï¼Œ**è·ç¦»è¶ŠçŸ­ä¼˜å…ˆåº¦è¶Šé«˜**ã€‚

ç›¸æ¯”è¾ƒå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œæœ‰ç›®çš„æ€§æœç´¢å‡å°‘äº†å¾ˆå¤šä¸å¿…è¦çš„è®¡ç®—ã€‚

ä½†æ˜¯ Best First Search æ‰¾å‡ºçš„è·¯å¾„**ä¸ä¸€å®šæ˜¯æœ€ä¼˜è§£**ã€‚

# A\*

A\*ï¼ˆA-starï¼‰ç®—æ³•æ˜¯ä¸€ç§ç”¨äºŽå›¾æœç´¢çš„å¯å‘å¼ç®—æ³•ï¼Œå¹¿æ³›åº”ç”¨äºŽè·¯å¾„å¯»æ‰¾å’Œå›¾éåŽ†ã€‚å®ƒç»“åˆäº† Dijkstra ç®—æ³•çš„æœ€çŸ­è·¯å¾„æœç´¢å’Œå¯å‘å¼æ–¹æ³•çš„é¢„åˆ¤èƒ½åŠ›ï¼Œæ—¢èƒ½ç¡®ä¿æ‰¾åˆ°æœ€ä¼˜è·¯å¾„ï¼Œåˆåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹é«˜æ•ˆè¿è¡Œã€‚

## 1. **åŸºæœ¬æ¦‚å¿µ**

- **å¯å‘å¼æœç´¢**ï¼šä½¿ç”¨å¯å‘å¼å‡½æ•°ä¼°è®¡å½“å‰èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„ä»£ä»·ï¼Œä»Žè€ŒæŒ‡å¯¼æœç´¢æ–¹å‘ã€‚
- **è¯„ä¼°å‡½æ•°**ï¼šA\*ç®—æ³•ä½¿ç”¨è¯„ä¼°å‡½æ•°`(f(n) = g(n) + h(n))`ï¼Œå…¶ä¸­ï¼š
  - (g(n))ï¼šä»Žèµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹ n çš„å®žé™…ä»£ä»·ã€‚æœ‰æ—¶å¯ä»¥é€šè¿‡ g(n-1)è®¡ç®—å¾—æ¥ã€‚
  - \(h(n)\)ï¼šä»Žå½“å‰èŠ‚ç‚¹ n åˆ°ç›®æ ‡èŠ‚ç‚¹çš„ä¼°è®¡ä»£ä»·ï¼ˆå¯å‘å¼å‡½æ•°ï¼‰ã€‚

## 2. **ç®—æ³•æ­¥éª¤**

A\*ç®—æ³•ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆPriority Queueï¼‰æ¥å®žçŽ°ï¼Œå…¶æ­¥éª¤å¦‚ä¸‹ï¼š

1. **åˆå§‹åŒ–**ï¼š
   - å°†èµ·å§‹èŠ‚ç‚¹æ”¾å…¥å¼€æ”¾åˆ—è¡¨ï¼ˆOpen Listï¼‰ï¼Œåˆå§‹çš„\(g(n) = 0\)ã€‚
   - å…³é—­åˆ—è¡¨ï¼ˆClosed Listï¼‰ç”¨äºŽå­˜å‚¨å·²è®¿é—®èŠ‚ç‚¹ã€‚
2. **è¿­ä»£è¿‡ç¨‹**ï¼š
   - ä»Žå¼€æ”¾åˆ—è¡¨ä¸­å–å‡ºå…·æœ‰**æœ€ä½Ž\(f(n)\)å€¼**çš„èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹ã€‚
   - å¦‚æžœå½“å‰èŠ‚ç‚¹æ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼Œåˆ™ç»“æŸæœç´¢ï¼Œæž„å»ºè·¯å¾„ã€‚
   - å¦åˆ™ï¼Œå°†å½“å‰èŠ‚ç‚¹ç§»è‡³å…³é—­åˆ—è¡¨ã€‚
   - å¯¹å½“å‰èŠ‚ç‚¹çš„æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹ï¼š
     - å¦‚æžœç›¸é‚»èŠ‚ç‚¹åœ¨å…³é—­åˆ—è¡¨ä¸­ï¼Œåˆ™å¿½ç•¥ã€‚
     - è®¡ç®—ç›¸é‚»èŠ‚ç‚¹çš„\(g\)å€¼ï¼Œå¦‚æžœè¯¥èŠ‚ç‚¹ä¸åœ¨å¼€æ”¾åˆ—è¡¨ä¸­æˆ–æ–°çš„\(g\)å€¼æ›´å°ï¼Œåˆ™æ›´æ–°ç›¸é‚»èŠ‚ç‚¹çš„\(g\)å’Œ\(f\)å€¼ï¼Œå¹¶å°†å…¶çˆ¶èŠ‚ç‚¹è®¾ç½®ä¸ºå½“å‰èŠ‚ç‚¹ã€‚
     - å¦‚æžœç›¸é‚»èŠ‚ç‚¹ä¸åœ¨å¼€æ”¾åˆ—è¡¨ä¸­ï¼Œåˆ™å°†å…¶æ·»åŠ è¿›åŽ»ã€‚

![æˆªå›¾](/img/in-post/Pathfinding/aa1e9866f9578534e35c0087be33a6ac.png)

## 3. **ç®—æ³•å®žçŽ°**

ä»¥ä¸‹æ˜¯ A\*ç®—æ³•çš„ä¼ªä»£ç å’Œ Python å®žçŽ°ï¼š

#### ä¼ªä»£ç 

```plaintext
A*(start, goal):
    openList = priority queue containing start
    closedList = empty set

    g(start) = 0
    f(start) = g(start) + h(start)

    while openList is not empty:
        current = node in openList with lowest f(node)
        if current is goal:
            return reconstruct_path(goal)

        remove current from openList
        add current to closedList

        for each neighbor of current:
            if neighbor in closedList:
                continue

            tentative_g = g(current) + d(current, neighbor)

            if neighbor not in openList:
                add neighbor to openList
            elif tentative_g >= g(neighbor):
                continue

            set parent of neighbor to current
            g(neighbor) = tentative_g
            f(neighbor) = g(neighbor) + h(neighbor)

    return failure
```

#### Python å®žçŽ°

```python
import heapq

def a_star(graph, start, goal, h):
    open_list = []
    heapq.heappush(open_list, (0, start))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: h(start)}

    while open_list:
        _, current = heapq.heappop(open_list)

        if current == goal:
            return reconstruct_path(came_from, start, goal)

        for neighbor, cost in graph[current]:
            tentative_g_score = g_score[current] + cost
            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + h(neighbor)
                heapq.heappush(open_list, (f_score[neighbor], neighbor))

    return None

def reconstruct_path(came_from, start, goal):
    path = [goal]
    while path[-1] != start:
        path.append(came_from[path[-1]])
    path.reverse()
    return path
```

### 4. **å¯å‘å¼å‡½æ•°**

å¯å‘å¼å‡½æ•° \(h(n)\) æ˜¯ A\*ç®—æ³•çš„å…³é”®ï¼Œå…¶é€‰æ‹©ä¼šå½±å“ç®—æ³•çš„æ•ˆçŽ‡å’Œæ­£ç¡®æ€§ã€‚å¸¸ç”¨çš„å¯å‘å¼å‡½æ•°æœ‰ï¼š

- **æ›¼å“ˆé¡¿è·ç¦»**ï¼šé€‚ç”¨äºŽç½‘æ ¼å›¾ï¼Œæ¯æ¬¡ç§»åŠ¨çš„ä»£ä»·ç›¸ç­‰ã€‚
- **æ¬§å‡ é‡Œå¾—è·ç¦»**ï¼šé€‚ç”¨äºŽå®žé™…è·ç¦»ä½œä¸ºä»£ä»·çš„å›¾ã€‚
- **åˆ‡æ¯”é›ªå¤«è·ç¦»**ï¼šé€‚ç”¨äºŽå…è®¸å¯¹è§’ç§»åŠ¨çš„ç½‘æ ¼å›¾ã€‚

### 5. **åº”ç”¨åœºæ™¯**

A\*ç®—æ³•å¹¿æ³›åº”ç”¨äºŽéœ€è¦è·¯å¾„è§„åˆ’çš„é¢†åŸŸï¼ŒåŒ…æ‹¬ï¼š

- **æ¸¸æˆå¼€å‘**ï¼šNPC è·¯å¾„è§„åˆ’ã€è¿·å®«æ±‚è§£ã€‚
- **æœºå™¨äººå¯¼èˆª**ï¼šç§»åŠ¨æœºå™¨äººè·¯å¾„è§„åˆ’ã€‚
- **åœ°å›¾æœåŠ¡**ï¼šGPS å¯¼èˆªã€åœ°å›¾åº”ç”¨ä¸­çš„è·¯çº¿è§„åˆ’ã€‚

### æ€»ç»“

A\*ç®—æ³•æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§ä¸”çµæ´»çš„è·¯å¾„å¯»æ‰¾ç®—æ³•ï¼Œé€šè¿‡ç»“åˆå®žé™…ä»£ä»·å’Œå¯å‘å¼ä¼°è®¡ï¼Œå¯ä»¥é«˜æ•ˆåœ°æ‰¾åˆ°ä»Žèµ·ç‚¹åˆ°ç›®æ ‡ç‚¹çš„æœ€ä¼˜è·¯å¾„ã€‚åœ¨å®žé™…åº”ç”¨ä¸­ï¼Œé€‰æ‹©åˆé€‚çš„å¯å‘å¼å‡½æ•°æ˜¯ç¡®ä¿ç®—æ³•æ•ˆçŽ‡å’Œå‡†ç¡®æ€§çš„å…³é”®ã€‚

# Theta\*

Theta\*ç®—æ³•æ˜¯ A\*ç®—æ³•çš„æ‰©å±•ç‰ˆæœ¬ï¼Œå®ƒåœ¨è·¯å¾„è§„åˆ’ä¸­æä¾›äº†ä¸€ç§æ”¹è¿›ï¼ˆåŠ å…¥äº†å°„çº¿æŽ¢æµ‹ï¼‰ï¼Œèƒ½å¤Ÿç”Ÿæˆæ›´çŸ­ã€æ›´è‡ªç„¶çš„è·¯å¾„ï¼Œç‰¹åˆ«æ˜¯å¯¹äºŽç½‘æ ¼å›¾ã€‚Theta\*ç®—æ³•çš„ä¸»è¦ç‰¹ç‚¹æ˜¯å…è®¸**å¯¹è§’çº¿å’Œç›´çº¿**ç©¿è¶Šå¤šä¸ªç½‘æ ¼å•å…ƒï¼Œè€Œä¸ä»…ä»…æ˜¯ç§»åŠ¨åˆ°ç›¸é‚»çš„å•å…ƒï¼Œä»Žè€Œé¿å…äº† A\*ä¸­å¸¸è§çš„â€œé”¯é½¿çŠ¶â€è·¯å¾„ã€‚æ­¤æ—¶ä¸€èˆ¬ä½¿ç”¨æ¬§å¼è·ç¦»ã€‚

### 1. **åŸºæœ¬æ¦‚å¿µ**

- **çº¿æ€§æ’å€¼**ï¼šTheta\*é€šè¿‡çº¿æ€§æ’å€¼åˆ¤æ–­ä¸¤ç‚¹ä¹‹é—´çš„ç›´çº¿æ˜¯å¦å¯è¡Œï¼Œä»Žè€Œå‡å°‘è·¯å¾„ä¸­çš„æ‹ç‚¹ã€‚
- **äº²èŠ‚ç‚¹ï¼ˆParent Nodeï¼‰**ï¼šæ¯ä¸ªèŠ‚ç‚¹ä¸ä»…è®°å½•ä»Žå“ªä¸ªèŠ‚ç‚¹è®¿é—®åˆ°å®ƒï¼Œè¿˜è®°å½•è®¿é—®è¯¥èŠ‚ç‚¹æ—¶çš„èµ·å§‹èŠ‚ç‚¹ï¼Œè¿™æ ·å¯ä»¥è·³è¿‡ä¸­é—´èŠ‚ç‚¹è¿›è¡Œç›´æŽ¥è¿žæŽ¥ã€‚

### 2. **ç®—æ³•æ­¥éª¤**

Theta\*ç®—æ³•åœ¨ A\*ç®—æ³•çš„åŸºç¡€ä¸Šè¿›è¡Œä¿®æ”¹ï¼Œå…¶æ­¥éª¤å¦‚ä¸‹ï¼š

1. **åˆå§‹åŒ–**ï¼š
   - å°†èµ·å§‹èŠ‚ç‚¹æ”¾å…¥å¼€æ”¾åˆ—è¡¨ï¼ˆOpen Listï¼‰ï¼Œå¹¶å°†å…¶çˆ¶èŠ‚ç‚¹è®¾ä¸ºè‡ªèº«ã€‚
   - åˆ›å»ºè®°å½•å„èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ˆParentï¼‰å’Œ\(g\)å€¼çš„æ•°ç»„ã€‚
2. **è¿­ä»£è¿‡ç¨‹**ï¼š
   - ä»Žå¼€æ”¾åˆ—è¡¨ä¸­å–å‡ºå…·æœ‰æœ€ä½Ž\(f(n)\)å€¼çš„èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹ã€‚
   - å¦‚æžœå½“å‰èŠ‚ç‚¹æ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼Œåˆ™ç»“æŸæœç´¢ï¼Œæž„å»ºè·¯å¾„ã€‚
   - å¦åˆ™ï¼Œå°†å½“å‰èŠ‚ç‚¹ç§»è‡³å…³é—­åˆ—è¡¨ã€‚
   - å¯¹å½“å‰èŠ‚ç‚¹çš„æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹ï¼š
     - å¦‚æžœç›¸é‚»èŠ‚ç‚¹åœ¨å…³é—­åˆ—è¡¨ä¸­ï¼Œåˆ™å¿½ç•¥ã€‚
     - **è®¡ç®—ä»Žå½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ç›´æŽ¥åˆ°ç›¸é‚»èŠ‚ç‚¹çš„ä»£ä»·ï¼ˆå³ç›´çº¿è·ç¦»ï¼‰ï¼Œå¦‚æžœæ¯”ä»Žå½“å‰èŠ‚ç‚¹å†åˆ°ç›¸é‚»èŠ‚ç‚¹çš„ä»£ä»·å°ï¼Œåˆ™æ›´æ–°ç›¸é‚»èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸ºå½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œå¦åˆ™æ›´æ–°ä¸ºå½“å‰èŠ‚ç‚¹ã€‚**ï¼ˆå’Œ A\*ç®—æ³•çš„ä¸»è¦åŒºåˆ«ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼ŒðŸŸ¦ ä¸ºå½“å‰èŠ‚ç‚¹ï¼ŒðŸ”µ ä¸ºçˆ¶èŠ‚ç‚¹ï¼ŒðŸ”º ä¸ºç›¸é‚»èŠ‚ç‚¹ã€‚å¯ä»¥çœ‹åˆ°ä¸Šä¸‹ä¸¤ä¸ªç›¸é‚»èŠ‚ç‚¹å¯ä»¥ç›´æŽ¥å’Œçˆ¶èŠ‚ç‚¹ç›¸è¿žï¼ˆ$cost = \sqrt{2}$ï¼‰ï¼Œè€Œæ— éœ€ç»ç”±å½“å‰èŠ‚ç‚¹ï¼ˆ$cost=2$ï¼‰ï¼‰
     - æ›´æ–°ç›¸é‚»èŠ‚ç‚¹çš„\(g\)å€¼å’Œ\(f\)å€¼ï¼Œå¦‚æžœç›¸é‚»èŠ‚ç‚¹ä¸åœ¨å¼€æ”¾åˆ—è¡¨ä¸­ï¼Œåˆ™å°†å…¶æ·»åŠ è¿›åŽ»ã€‚

![æˆªå›¾](/img/in-post/Pathfinding/a5d2b57d13201afd07ed6c28ac90b0d3.png)

### 3. **ç®—æ³•å®žçŽ°**

ä»¥ä¸‹æ˜¯ Theta\*ç®—æ³•çš„ä¼ªä»£ç å’Œ Python å®žçŽ°ï¼š

#### ä¼ªä»£ç 

```plaintext
Theta*(start, goal):
    openList = priority queue containing start
    closedList = empty set
    parent[start] = start
    g(start) = 0
    f(start) = g(start) + h(start)

    while openList is not empty:
        current = node in openList with lowest f(node)
        if current is goal:
            return reconstruct_path(parent, start, goal)

        remove current from openList
        add current to closedList

        for each neighbor of current:
            if neighbor in closedList:
                continue

            if line_of_sight(parent[current], neighbor):
                tentative_g = g(parent[current]) + distance(parent[current], neighbor)
                if tentative_g < g(neighbor):
                    parent[neighbor] = parent[current]
                    g(neighbor) = tentative_g
                    f(neighbor) = g(neighbor) + h(neighbor)
                    if neighbor not in openList:
                        add neighbor to openList
            else:
                tentative_g = g(current) + distance(current, neighbor)
                if tentative_g < g(neighbor):
                    parent[neighbor] = current
                    g(neighbor) = tentative_g
                    f(neighbor) = g(neighbor) + h(neighbor)
                    if neighbor not in openList:
                        add neighbor to openList

    return failure
```

#### Python å®žçŽ°

```python
import heapq
import math

def line_of_sight(grid, start, end):
    # å®žçŽ°çº¿æ€§æ’å€¼æ£€æŸ¥ä¸¤ç‚¹ä¹‹é—´çš„ç›´çº¿æ˜¯å¦å¯é€š
    x0, y0 = start
    x1, y1 = end
    dx, dy = x1 - x0, y1 - y0
    steps = max(abs(dx), abs(dy))
    for i in range(steps + 1):
        x = int(x0 + i * dx / steps)
        y = int(y0 + i * dy / steps)
        if grid[y][x] == 1:  # å‡è®¾1ä»£è¡¨éšœç¢ç‰©
            return False
    return True

def theta_star(grid, start, goal, h):
    open_list = []
    heapq.heappush(open_list, (0, start))
    parent = {start: start}
    g_score = {start: 0}
    f_score = {start: h(start)}

    while open_list:
        _, current = heapq.heappop(open_list)

        if current == goal:
            return reconstruct_path(parent, start, goal)

        for neighbor in get_neighbors(grid, current):
            if line_of_sight(grid, parent[current], neighbor):
                tentative_g_score = g_score[parent[current]] + distance(parent[current], neighbor)
                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    parent[neighbor] = parent[current]
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + h(neighbor)
                    heapq.heappush(open_list, (f_score[neighbor], neighbor))
            else:
                tentative_g_score = g_score[current] + distance(current, neighbor)
                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    parent[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + h(neighbor)
                    heapq.heappush(open_list, (f_score[neighbor], neighbor))

    return None

def distance(point1, point2):
    return math.hypot(point2[0] - point1[0], point2[1] - point1[1])

def reconstruct_path(parent, start, goal):
    path = [goal]
    while path[-1] != start:
        path.append(parent[path[-1]])
    path.reverse()
    return path

def get_neighbors(grid, node):
    neighbors = []
    x, y = node
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            if dx == 0 and dy == 0:
                continue
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(grid[0]) and 0 <= ny < len(grid):
                neighbors.append((nx, ny))
    return neighbors
```

### 4. **åº”ç”¨åœºæ™¯**

Theta\*ç®—æ³•é€‚ç”¨äºŽéœ€è¦ç”Ÿæˆæ›´ç›´ã€æ›´è‡ªç„¶è·¯å¾„çš„åœºæ™¯ï¼Œå¦‚ï¼š

- **æœºå™¨äººå¯¼èˆª**ï¼šç§»åŠ¨æœºå™¨äººè·¯å¾„è§„åˆ’ï¼Œå‡å°‘è½¬å¼¯ï¼Œæé«˜è·¯å¾„æ•ˆçŽ‡ã€‚
- **æ¸¸æˆå¼€å‘**ï¼šç”Ÿæˆè‡ªç„¶çš„ NPC è·¯å¾„ï¼Œé¿å…é”¯é½¿çŠ¶è·¯å¾„ã€‚
- **åœ°å›¾æœåŠ¡**ï¼šå¤æ‚åœ°å½¢ä¸­çš„è·¯å¾„è§„åˆ’ï¼Œå¦‚æ— äººæœºå¯¼èˆªã€‚

### æ€»ç»“

Theta\*ç®—æ³•é€šè¿‡å…è®¸**èŠ‚ç‚¹ä¹‹é—´çš„ç›´æŽ¥è¿žæŽ¥**ï¼Œæé«˜äº†è·¯å¾„çš„å¹³æ»‘æ€§å’Œè‡ªç„¶æ€§ã€‚å®ƒåœ¨å®žé™…åº”ç”¨ä¸­ç‰¹åˆ«é€‚ç”¨äºŽéœ€è¦ç”Ÿæˆç›´çº¿è·¯å¾„æˆ–å‡å°‘è½¬å¼¯çš„åœºæ™¯ï¼Œå¦‚æœºå™¨äººå¯¼èˆªå’Œæ¸¸æˆå¼€å‘ã€‚åœ¨è¿™äº›é¢†åŸŸï¼ŒTheta\*æä¾›äº†ä¸€ç§æ›´ä¼˜çš„è·¯å¾„è§„åˆ’æ–¹æ¡ˆã€‚

![æˆªå›¾](/img/in-post/Pathfinding/c839fd15aa821e1b717e796196fa5530.png)

# è·³ç‚¹æœç´¢ç®—æ³•

è·³ç‚¹æœç´¢ï¼ˆJump Point Searchï¼ŒJPSï¼‰æ˜¯ä¸€ç§ä¼˜åŒ–çš„è·¯å¾„æœç´¢ç®—æ³•ï¼Œä¸“é—¨è®¾è®¡ç”¨äºŽåŠ é€Ÿ A*ç®—æ³•åœ¨ç½‘æ ¼å›¾ä¸Šçš„è¿è¡Œã€‚JPS é€šè¿‡è·³è¿‡å†—ä½™èŠ‚ç‚¹ï¼Œå‡å°‘äº† A*ç®—æ³•çš„æœç´¢ç©ºé—´ï¼Œä»Žè€Œæé«˜äº†æ•ˆçŽ‡ã€‚

### 1. **åŸºæœ¬æ¦‚å¿µ**

- **è·³ç‚¹ï¼ˆJump Pointï¼‰**ï¼šæ˜¯è·¯å¾„ä¸Šçš„å…³é”®ç‚¹ï¼Œè¿™äº›ç‚¹å†³å®šäº†è·¯å¾„çš„è½¬æŠ˜ç‚¹æˆ–æ–¹å‘æ”¹å˜ç‚¹ã€‚
- **å¼ºåˆ¶é‚»å±…ï¼ˆForced Neighborï¼‰**ï¼šåœ¨æœç´¢è¿‡ç¨‹ä¸­å¿…é¡»è€ƒè™‘çš„é‚»å±…èŠ‚ç‚¹ï¼Œä»¥ç¡®ä¿ä¸ä¼šé—æ¼æ½œåœ¨çš„æœ€çŸ­è·¯å¾„ã€‚ï¼ˆåœ¨ç¢°æ’žä½“å››å‘¨ï¼‰

### 2. **ç®—æ³•æ­¥éª¤**

JPS é€šè¿‡ä»¥ä¸‹æ­¥éª¤è¿›è¡Œä¼˜åŒ–ï¼š

1. **åˆå§‹åŒ–**ï¼š
   - ä¸Ž A\*ç®—æ³•ç±»ä¼¼ï¼Œåˆå§‹åŒ–èµ·å§‹èŠ‚ç‚¹çš„å¼€æ”¾åˆ—è¡¨ã€å…³é—­åˆ—è¡¨ä»¥åŠç›¸åº”çš„ä»£ä»·å€¼ã€‚
2. **è·³è·ƒè¿‡ç¨‹**ï¼š
   - ä»Žå½“å‰èŠ‚ç‚¹æ²¿ä¸€ä¸ªæ–¹å‘â€œè·³è·ƒâ€ï¼Œç›´åˆ°é‡åˆ°ä»¥ä¸‹æƒ…å†µä¹‹ä¸€ï¼š
     - åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹ã€‚
     - é‡åˆ°éšœç¢ç‰©ã€‚
     - æ‰¾åˆ°ä¸€ä¸ªè·³ç‚¹ï¼ˆè½¬æŠ˜ç‚¹æˆ–å¼ºåˆ¶é‚»å±…ï¼‰ã€‚
3. **è·³ç‚¹çš„ç¡®å®š**ï¼š
   - ä½¿ç”¨å¯å‘å¼æ–¹æ³•åˆ¤æ–­å½“å‰æ–¹å‘ä¸Šçš„å¼ºåˆ¶é‚»å±…ï¼Œç¡®å®šè·³ç‚¹ã€‚
   - å¼ºåˆ¶é‚»å±…æ˜¯åœ¨å½“å‰æ–¹å‘ä¸Šå¿…é¡»æ£€æŸ¥çš„èŠ‚ç‚¹ï¼Œç¡®ä¿è·¯å¾„ä¸ä¼šé—æ¼ã€‚
4. **è·¯å¾„è®°å½•**ï¼š
   - è®°å½•è·¯å¾„ä¸Šçš„è·³ç‚¹ï¼Œå¹¶å°†è¿™äº›è·³ç‚¹åŠ å…¥å¼€æ”¾åˆ—è¡¨ã€‚

å¦‚ä¸‹å›¾ï¼šè“è‰²å’Œç»¿è‰²ç‚¹ä¸ºè·³ç‚¹ï¼Œè“è‰²ä¸ºå·²è®¿é—®çš„è·³ç‚¹

![æˆªå›¾](/img/in-post/Pathfinding/7bff866791501b056a8bfb1d43bf8373.png)

### 3. **ç®—æ³•å®žçŽ°**

ä»¥ä¸‹æ˜¯ JPS ç®—æ³•çš„ä¼ªä»£ç å’Œ Python å®žçŽ°ï¼š

#### ä¼ªä»£ç 

```plaintext
JPS(start, goal):
    openList = priority queue containing start
    closedList = empty set
    g(start) = 0
    f(start) = g(start) + h(start)

    while openList is not empty:
        current = node in openList with lowest f(node)
        if current is goal:
            return reconstruct_path(current)

        remove current from openList
        add current to closedList

        for each direction in possible_directions:
            neighbor = jump(current, direction, goal)
            if neighbor is not None:
                if neighbor in closedList:
                    continue
                tentative_g = g(current) + distance(current, neighbor)
                if neighbor not in openList or tentative_g < g(neighbor):
                    parent[neighbor] = current
                    g(neighbor) = tentative_g
                    f(neighbor) = g(neighbor) + h(neighbor)
                    if neighbor not in openList:
                        add neighbor to openList

    return failure

jump(current, direction, goal):
    next = current + direction
    if next is blocked or out of bounds:
        return None
    if next == goal:
        return next
    if has_forced_neighbors(next, direction):
        return next
    return jump(next, direction, goal)
```

#### Python å®žçŽ°

```python
import heapq
import math

def jps(grid, start, goal, h):
    open_list = []
    heapq.heappush(open_list, (0, start))
    g_score = {start: 0}
    parent = {start: None}

    while open_list:
        _, current = heapq.heappop(open_list)

        if current == goal:
            return reconstruct_path(parent, start, goal)

        for direction in get_directions():
            neighbor = jump(grid, current, direction, goal, parent, g_score)
            if neighbor:
                tentative_g = g_score[current] + distance(current, neighbor)
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    g_score[neighbor] = tentative_g
                    f_score = tentative_g + h(neighbor)
                    heapq.heappush(open_list, (f_score, neighbor))
                    parent[neighbor] = current

    return None

def jump(grid, current, direction, goal, parent, g_score):
    x, y = current
    dx, dy = direction
    next_node = (x + dx, y + dy)

    # éšœç¢ç‰©æˆ–è€…è¾¹ç•Œ
    if not in_bounds(grid, next_node) or grid[next_node[1]][next_node[0]] == 1:
        return None
    # ç»ˆç‚¹
    if next_node == goal:
        return next_node
    # æ˜¯å¦æœ‰å¼ºåˆ¶é‚»å±…
    if has_forced_neighbors(grid, next_node, direction):
        return next_node
    # æ–œæ–¹å‘
    if dx != 0 and dy != 0:
        # åˆ†è§£æˆæ°´å¹³å’Œåž‚ç›´åˆ†é‡æœç´¢
        # å¦‚æžœè¿™ä¸¤ä¸ªæœç´¢æ–¹å‘ä¸Šæœ‰ç»ˆç‚¹æˆ–è€…å¼ºåˆ¶é‚»å±…ï¼Œåˆ™è¿”å›žè¿™ä¸€èŠ‚ç‚¹
        # è¡¨ç¤ºæ­¤èŠ‚ç‚¹æ˜¯ä¸€ä¸ªè·³ç‚¹
        if jump(grid, next_node, (dx, 0), goal, parent, g_score) or jump(grid, next_node, (0, dy), goal, parent, g_score):
            return next_node
    # ç»§ç»­æ²¿ç€æ–¹å‘æœç´¢
    return jump(grid, next_node, direction, goal, parent, g_score)

def get_directions():
    return [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]

def distance(node1, node2):
    return math.hypot(node2[0] - node1[0], node2[1] - node1[1])

def reconstruct_path(parent, start, goal):
    path = [goal]
    while path[-1] != start:
        path.append(parent[path[-1]])
    path.reverse()
    return path

def in_bounds(grid, node):
    x, y = node
    return 0 <= x < len(grid[0]) and 0 <= y < len(grid)

def has_forced_neighbors(grid, node, direction):
    x, y = node
    dx, dy = direction
    neighbors = [
        (x - dy, y + dx), (x + dy, y - dx),  # Orthogonal to direction
        (x - dx, y + dy), (x + dx, y - dy)   # Diagonal to direction
    ]
    for nx, ny in neighbors:
        if in_bounds(grid, (nx, ny)) and grid[ny][nx] == 0:
            return True
    return False
```

#### ä¸»æµç¨‹åˆ†æžï¼š

è¿™æ®µä»£ç å®žçŽ°äº†è·³ç‚¹æœç´¢ï¼ˆJump Point Search, JPSï¼‰ç®—æ³•ä¸­çš„ä¸»å¾ªçŽ¯é€»è¾‘ï¼Œç»“åˆ A\*ç®—æ³•çš„å¯å‘å¼æœç´¢æ¥æ‰¾åˆ°ä»Žèµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€ä¼˜è·¯å¾„ã€‚ä¸‹é¢æ˜¯é€è¡Œè§£æžï¼š

```python
while open_list:
    _, current = heapq.heappop(open_list)

    if current == goal:
        return reconstruct_path(parent, start, goal)

    for direction in get_directions():
        neighbor = jump(grid, current, direction, goal, parent, g_score)
        if neighbor:
            tentative_g = g_score[current] + distance(current, neighbor)
            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                g_score[neighbor] = tentative_g
                f_score = tentative_g + h(neighbor)
                heapq.heappush(open_list, (f_score, neighbor))
                parent[neighbor] = current
```

##### è¯¦ç»†è§£é‡Š

1. **ä¸»å¾ªçŽ¯**ï¼š
   ```python
   while open_list:
   ```
   - å½“`open_list`ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰ä¸ä¸ºç©ºæ—¶ï¼ŒæŒç»­æ‰§è¡Œå¾ªçŽ¯ã€‚`open_list`ä¿å­˜å¾…æŽ¢ç´¢çš„èŠ‚ç‚¹ã€‚
2. **ä»Žä¼˜å…ˆé˜Ÿåˆ—ä¸­å–å‡ºå½“å‰èŠ‚ç‚¹**ï¼š
   ```python
   _, current = heapq.heappop(open_list)
   ```
   - ä½¿ç”¨`heapq.heappop`ä»Žä¼˜å…ˆé˜Ÿåˆ—`open_list`ä¸­å–å‡ºä¼˜å…ˆçº§æœ€é«˜çš„èŠ‚ç‚¹ï¼Œå³å…·æœ‰æœ€ä½Ž`f_score`çš„èŠ‚ç‚¹ï¼Œå­˜å…¥`current`ã€‚`_`å­˜å‚¨çš„æ˜¯`f_score`ï¼Œä½†è¿™é‡Œå¹¶ä¸éœ€è¦ä½¿ç”¨å®ƒã€‚
3. **æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹**ï¼š
   ```python
   if current == goal:
       return reconstruct_path(parent, start, goal)
   ```
   - å¦‚æžœå½“å‰èŠ‚ç‚¹æ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼Œè°ƒç”¨`reconstruct_path`å‡½æ•°é‡å»ºè·¯å¾„ï¼Œå¹¶è¿”å›žç»“æžœã€‚
4. **èŽ·å–æ‰€æœ‰å¯èƒ½çš„ç§»åŠ¨æ–¹å‘**ï¼š
   ```python
   for direction in get_directions():
   ```
   - èŽ·å–æ‰€æœ‰å¯èƒ½çš„ç§»åŠ¨æ–¹å‘ï¼ˆä¾‹å¦‚ï¼Œä¸Šã€ä¸‹ã€å·¦ã€å³æˆ–å¯¹è§’çº¿ï¼‰ã€‚
5. **è·³ç‚¹æœç´¢**ï¼š
   ```python
   neighbor = jump(grid, current, direction, goal, parent, g_score)
   ```
   - è°ƒç”¨`jump`å‡½æ•°ä»Žå½“å‰èŠ‚ç‚¹æ²¿æŒ‡å®šæ–¹å‘è¿›è¡Œè·³è·ƒï¼Œå¯»æ‰¾ä¸‹ä¸€ä¸ªè·³ç‚¹ã€‚è¿”å›žçš„`neighbor`æ˜¯æ‰¾åˆ°çš„ä¸‹ä¸€ä¸ªè·³ç‚¹æˆ–`None`ã€‚
6. **å¤„ç†æ‰¾åˆ°çš„é‚»å±…èŠ‚ç‚¹**ï¼š
   ```python
   if neighbor:
       tentative_g = g_score[current] + distance(current, neighbor)
       if neighbor not in g_score or tentative_g < g_score[neighbor]:
           g_score[neighbor] = tentative_g
           f_score = tentative_g + h(neighbor)
           heapq.heappush(open_list, (f_score, neighbor))
           parent[neighbor] = current
   ```
   - å¦‚æžœæ‰¾åˆ°æœ‰æ•ˆçš„é‚»å±…èŠ‚ç‚¹ï¼š
     - è®¡ç®—ä»Žèµ·ç‚¹åˆ°è¯¥é‚»å±…èŠ‚ç‚¹çš„ä¸´æ—¶è·ç¦»ï¼ˆ`tentative_g`ï¼‰ã€‚
     - å¦‚æžœè¯¥é‚»å±…èŠ‚ç‚¹æœªè¢«æŽ¢ç´¢è¿‡ï¼Œæˆ–æ‰¾åˆ°äº†ä¸€æ¡æ›´çŸ­çš„è·¯å¾„åˆ°è¯¥é‚»å±…èŠ‚ç‚¹ï¼š
       - æ›´æ–°é‚»å±…èŠ‚ç‚¹çš„`g_score`ã€‚
       - è®¡ç®—é‚»å±…èŠ‚ç‚¹çš„`f_score`ï¼ˆ`f_score = g_score + h_score`ï¼‰ï¼Œå…¶ä¸­`h(neighbor)`æ˜¯ä»Žé‚»å±…èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„å¯å‘å¼ä¼°è®¡è·ç¦»ã€‚
       - å°†é‚»å±…èŠ‚ç‚¹åŠå…¶`f_score`åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—`open_list`ã€‚
       - è®°å½•é‚»å±…èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸ºå½“å‰èŠ‚ç‚¹ã€‚

##### ä¸»è¦å‡½æ•°å’Œæ•°æ®ç»“æž„

- **`open_list`**: ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå­˜å‚¨å¾…æŽ¢ç´¢çš„èŠ‚ç‚¹åŠå…¶`f_score`ã€‚
- **`heapq.heappop`**: ä»Žä¼˜å…ˆé˜Ÿåˆ—ä¸­å–å‡ºå…·æœ‰æœ€ä½Ž`f_score`çš„èŠ‚ç‚¹ã€‚
- **`goal`**: ç›®æ ‡èŠ‚ç‚¹ã€‚
- **`reconstruct_path`**: é‡å»ºä»Žèµ·ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„ã€‚
- **`get_directions`**: èŽ·å–æ‰€æœ‰å¯èƒ½çš„ç§»åŠ¨æ–¹å‘ã€‚
- **`jump`**: æ‰§è¡Œè·³ç‚¹æœç´¢ï¼Œä»Žå½“å‰èŠ‚ç‚¹æ²¿æŒ‡å®šæ–¹å‘è·³è·ƒï¼Œæ‰¾åˆ°ä¸‹ä¸€ä¸ªè·³ç‚¹ã€‚
- **`g_score`**: å­—å…¸ï¼Œå­˜å‚¨ä»Žèµ·ç‚¹åˆ°å„èŠ‚ç‚¹çš„å®žé™…è·ç¦»ã€‚
- **`distance`**: è®¡ç®—ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„å®žé™…è·ç¦»ã€‚
- **`h`**: å¯å‘å‡½æ•°ï¼Œä¼°è®¡ä»ŽæŸèŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·ç¦»ã€‚
- **`heapq.heappush`**: å°†èŠ‚ç‚¹åŠå…¶`f_score`åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—`open_list`ã€‚
- **`parent`**: å­—å…¸ï¼Œå­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œç”¨äºŽè·¯å¾„é‡å»ºã€‚

### 4. **å…³é”®ç‚¹è§£é‡Š**

- **è·³ç‚¹**ï¼šè·³ç‚¹æ˜¯è·¯å¾„ä¸Šçš„å…³é”®ç‚¹ï¼Œè·³è¿‡äº†ä¸­é—´çš„å†—ä½™èŠ‚ç‚¹ã€‚
- **å¼ºåˆ¶é‚»å±…**ï¼šåœ¨åˆ¤æ–­è·³ç‚¹æ—¶ï¼Œå¿…é¡»æ£€æŸ¥çš„é‚»å±…èŠ‚ç‚¹ï¼Œä»¥ç¡®ä¿ä¸ä¼šé—æ¼æœ€çŸ­è·¯å¾„ã€‚
- **çº¿æ€§æœç´¢**ï¼šä»Žå½“å‰èŠ‚ç‚¹æ²¿ä¸€ä¸ªæ–¹å‘è¿›è¡Œçº¿æ€§æœç´¢ï¼Œç›´åˆ°æ‰¾åˆ°è·³ç‚¹æˆ–é‡åˆ°éšœç¢ã€‚

### 5. **åº”ç”¨åœºæ™¯**

JPS ç‰¹åˆ«é€‚åˆç”¨äºŽä»¥ä¸‹åœºæ™¯ï¼š

- **æ¸¸æˆå¼€å‘**ï¼šåœ¨å¤§è§„æ¨¡ç½‘æ ¼åœ°å›¾ä¸­ï¼Œå¿«é€Ÿç”Ÿæˆæœ€ä¼˜è·¯å¾„ã€‚
- **æœºå™¨äººå¯¼èˆª**ï¼šåœ¨ç½‘æ ¼åŒ–çŽ¯å¢ƒä¸­ï¼Œè§„åˆ’é«˜æ•ˆè·¯å¾„ã€‚
- **åœ°å›¾æœåŠ¡**ï¼šä¼˜åŒ–å¤§è§„æ¨¡ç½‘æ ¼åœ°å›¾ä¸Šçš„è·¯å¾„æŸ¥è¯¢ã€‚

### 6. **æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦**

- **æ—¶é—´å¤æ‚åº¦**ï¼šåœ¨ç†æƒ³æƒ…å†µä¸‹ï¼ŒJPS æ˜¾è‘—å‡å°‘äº†èŠ‚ç‚¹çš„æ‰©å±•æ•°é‡ï¼Œå› æ­¤æ¯” A*æ›´å¿«ï¼Œå°¤å…¶åœ¨ç©ºæ—·åŒºåŸŸã€‚ç„¶è€Œï¼Œæœ€åæƒ…å†µä¸‹ï¼Œæ—¶é—´å¤æ‚åº¦ä»ä¸Ž A*ç›¸åŒï¼Œä¸º O(b^d)ï¼Œå…¶ä¸­ b æ˜¯åˆ†æ”¯å› å­ï¼Œd æ˜¯è·¯å¾„æ·±åº¦ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼šä¸Ž A\*ç±»ä¼¼ï¼Œä¸º O(b^d)ï¼Œå› ä¸ºéœ€è¦å­˜å‚¨å¼€æ”¾åˆ—è¡¨å’Œå…³é—­åˆ—è¡¨ä¸­çš„èŠ‚ç‚¹ã€‚

### æ€»ç»“

è·³ç‚¹æœç´¢é€šè¿‡è·³è¿‡å†—ä½™èŠ‚ç‚¹ï¼Œä¼˜åŒ–äº† A\*ç®—æ³•åœ¨ç½‘æ ¼å›¾ä¸Šçš„è¿è¡Œã€‚å®ƒèƒ½å¤Ÿæ˜¾è‘—å‡å°‘æœç´¢ç©ºé—´ï¼Œä»Žè€Œæé«˜è·¯å¾„è§„åˆ’çš„æ•ˆçŽ‡ï¼Œé€‚ç”¨äºŽéœ€è¦é«˜æ•ˆè·¯å¾„æœç´¢çš„å„ç§åº”ç”¨åœºæ™¯ã€‚

_æ³¨ï¼šä»¥ä¸Šéƒ¨åˆ†å†…å®¹é€šè¿‡ ChatGpt ç”Ÿæˆ_
